package orh;

import groovy.json.JsonOutput;
import groovy.lang.Closure;
import groovy.lang.Writable;
import groovy.text.Template;
import groovy.text.markup.BaseTemplate;
import groovy.text.markup.DelegatingIndentWriter;
import groovy.text.markup.MarkupTemplateEngine;
import groovy.text.markup.TemplateConfiguration;
import org.codehaus.groovy.control.io.NullWriter;
import org.codehaus.groovy.runtime.ExceptionUtils;
import org.codehaus.groovy.runtime.InvokerHelper;
import org.codehaus.groovy.runtime.ResourceGroovyMethods;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.net.URL;
import java.util.*;

import static groovy.xml.XmlUtil.escapeXml;

/**
 * <p>All templates compiled through {@link MarkupTemplateEngine} extend this abstract class,
 * which provides a number of utility methods to generate markup. An instance of this class can be obtained
 * after calling {@link Template#make()} or {@link Template#make(Map)})} on
 * a template generated by {@link MarkupTemplateEngine#createTemplate(java.io.Reader)}.</p>
 *
 * <p>It is advised to use a distinct template instance for each thread (or more simply, each rendered document)
 * for thread safety and avoiding mixing models.</p>
 *
 * <p>For the application needs, it is possible to provide more helper methods by extending this class and
 * configuring the base template class using the {@link TemplateConfiguration#setBaseTemplateClass(Class)}
 * method.</p>
 *
 * @author Cedric Champeau
 */
public abstract class JSONTemplate extends BaseTemplate {

    private Map map;

    public JSONTemplate(final MarkupTemplateEngine templateEngine, final Map model, final Map<String,String> modelTypes, final TemplateConfiguration configuration) {
        super(templateEngine, model, modelTypes, configuration);
        map = new HashMap();
    }

    public String stringOf(Closure cl) throws IOException {
        Object result = cl.call();
        return result.toString();
    }

    public Object iterator(String tagName, Object args) throws IOException {
        return null;
    }

    public Object iterator(Object args) throws IOException {
        return null;
    }

    public Object iterator() throws IOException {
        return null;
    }

    public static <T> T each(T self, Closure closure) {
//        each(InvokerHelper.asIterator(self), closure);
        return self;
    }

    public Object methodMissing(String tagName, Object args) throws IOException {
        Object o = getModel().get(tagName);
        if (o instanceof Closure) {
            if (args instanceof Object[]) {
                yieldUnescaped(((Closure) o).call((Object[])args));
                return this;
            }
            yieldUnescaped(((Closure) o).call(args));
            return this;
        } else if (args instanceof Object[]) {
            TagData tagData = new TagData(args).invoke();
            Object body = tagData.getBody();
            if (body != null) {
                Map currentMap = map;
                Map entryMap = new HashMap();
                if (body instanceof Closure) {
                    currentMap.put(tagName, entryMap);

                    map = entryMap;
                    ((Closure) body).call();
                    map = currentMap;
                } else {
                    currentMap.put(tagName, body);
                }
            }
            Map attributes = tagData.attributes;
            if (attributes != null) {
                Set<Map.Entry> entries = attributes.entrySet();
                for (Map.Entry e : entries) {
                    if (e.getValue() != null) {
                        Map currentMap = map;
                        Map entryMap = new HashMap();
                        if (e.getValue() instanceof Closure) {
                            currentMap.put(e.getKey(), entryMap);

                            map = entryMap;
                            ((Closure) e.getValue()).call();
                            map = currentMap;
                        } else {
                            currentMap.put(e.getKey(), e.getValue());
                        }
                    }
                }
            }
        }
        return this;
    }

    private class TagData {
        private final Object[] array;
        private Map attributes;
        private Object body;

        public TagData(final Object args) {
            this.array = (Object[])args;
        }

        public Map getAttributes() {
            return attributes;
        }

        public Object getBody() {
            return body;
        }

        public TagData invoke() {
            attributes = null;
            body = null;
            for (Object o : array) {
                if (o instanceof Map) {
                    attributes = (Map) o;
                } else {
                    body = o;
                }
            }
            return this;
        }
    }

    public String toString() {
        run();
        return JsonOutput.toJson(map);
    }
}
